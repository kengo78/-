## Go言語についての学んだこと

- ファイルの整形
```go
go fmt "ソースファイル名"
```

- Goファイルのコンパイル
```go
go build -o "実行ファイル名" "ソースファイル名"
```

- コンパイルと実行を同時に行う
```go
go run "ソースファイル名"
```

- 型宣言
```go
//int型からMyIntegerを宣言
type MyInteger int

//MyInterger型の変数をを作成
var i MyInteger = 123

//int型と同様に演算ん可能
i += 1

pmt.Println(i)
//出力 124

//構造体の宣言
type mystruct struct {
    a int 
    b int
}
```
Go言語のソースファイルは「パッケージ」という単位で、グルーピングされて、各パッケージには、1つ以上のソースファイルが所属する。  
ソースファイルは、同一パッケージに所属している別のソースファイル内で、宣言された定数、型、変数、関数といった識別子にアクセスすることができる。  
関数ないで定義したローカルな変数については、同一パッケージ内でも参照ができない。

ソースファイルは必ずいずれかのパッケージに所属する必要がある。その際の宣言方法は以下の通り。
```go
package "パッケージ名"
```
パッケージ名は、すべて小文字かつ1単語で構成されることが推奨されている。

変数の宣言の際に、先頭を大文字にすることで、パッケージ外で、宣言された変数にアクセスできるようになる。

- importしたパッケージに任意の名前をつける
```go
import "任意の名前" "packageのpath"
```
- 未使用のimport
これは、コンパイル時にエラーが起きてしまうので、ブランク識別子を用いて
```go
import _ "package path"
```

- 独自パッケージを使用する際の注意点
ディレクトリの最上位パスをフルパスで環境変数「GOPATH」に登録する必要がある。

- for文
```go
package main

import "fmt"

func main() {
    for i := 0;i < 5;i++ {
        fmt.Println(i)
    }
    //出力は1,2,3,4,5と一行ずつ出力される。
}
/*
func main(){
    i := 0
    for i< 5 {
        fmt.Println(i)
        i ++ 
    }
}
*/
```
- range式を使用する場合
```go
package main 
import "fmt"

func main(){
    //配列の宣言と初期化
    arr := [...] int {0,1,2,3,4}

    //for 文
    for i:= range arr {
        fmt.Println(i)
    }
}
```

- switch文
```go
package main

import "fmt"

func main() {
    //ループ
    for i:= 0; i< 5; i++ {
        switch i {
            case 0:
                fmt.Println("0")
            case 1,2:
                fmt.Println("1または2")
            default:
                fmt.Println("その他")
        }
    }
}
/*出力は、
0
1または2
1または2
その他
その他
*/
```
## ポインタ
変数が存在するメモリ上の場所を「アドレス」といい、そのアドレスを格納可能な変数を「ポインタ」と呼ぶ。
たとえば、「int」型変数のアドレスを格納できるポインタの型は、「\*int」型であり、変数からアドレスを取得するときは、「&」(アドレス演算子)を使って、アドレスが示す変数にアクセスするときは、「\*」(間接参照演算子)を使用する。  
ポインタのコード例
```go
package main
import "fmt"

func main(){
    //int型のポインタ変数を宣言
    var ptr *int

    //int型の変数を宣言
    var i int = 12345

    //アドレス演算子を使って、iのアドレスをptrに代入
    ptr = &i

    //出力　
    fmt.Println("iのアドレス", &i)
    fmt.Println("ptrの値(変数iのアドレス):", ptr)

    fmt.Println("iの値:", i)
    fmt.Println("ポインタ経由のiの値", *ptr)

    //ポインタ経由でiの値を変更
    *ptr = 999

    //出力
    fmt.Println("ポインタ経由で変更したiの値", i)
    
}
//出力

### ポインタ私と値渡し
ある変数を函数に渡すと、実際は値のコピーが渡されるので、呼び出された函数ないで値を変更しても関数の呼び出し元の値には、影響がない。
一方で、値のポインタを函数に渡したときには、値の実態(ポインタの指し示す値)は関数の呼び出し元も先も同じなので、呼び出した函数ないで呼び出し元の値を変更することができる。
ポインタを用いて値を受け渡す→「ポインタ渡し」. 
値のコピーを受け渡す→「値渡し」

```go
package main

import "fmt"

func main() {
    //int型の変数を2つ宣言
    a,b := 1,1
    
    //函数に値を渡す
    //aは値渡し、bはポインタ渡し
    double(a, &b)
    //出力
    fmt.Println("値渡し", a)
    fmt.Println("ポインタ渡し", b)
}

func double(x int, y *int) {
    x = x*2
    *y = *y * 2
}
```
//出力
```
値渡し:1
ポインタ渡し:2
```

### 「new」組み込み函数によるメモリの割り当て
アドレスは、

変数は、アドレスを間接参照したときだけでなく、明示的にあたらいいメモリを割り当てることもできる。割り当てられたメモリは0値で初期化されて、割り当てたメモリが使われなくなったと判断されたら自動的に解放される。

```go
//int型のメモリの割り当て
var i *int = new(int)

//string型のメモリの割り当て
var s *string = new(string)
```

### ゼロ値
変数を明示的に初期化しなかったときに暗黙的に設定される初期値がゼロ値
変数の方によっては、ゼロ値は異なる。

### ラベルについて
ラベルとは「break」、「continue」、「goto」分の宛先となる識別子。

###　関数について
Go言語の関数の特徴として、関数の戻り値として、複数の値を一度に返すことができる。
```go
//関数の宣言
func 関数名(パラメータリスト)戻り値の型 {
    //処理
    //呼び出し元の復帰
    return 戻り値
}
```

```go
package main

import "fmt"

//足し算を行う関数の宣言
func plus(a int, b int) int {
    return a + b
}

//main関数は、パラメータ、戻り値を共に持たない
funct main() {
    answer := plus(1,2)
    fmt.Plintln(answer)
}
```
#### 多値を返す関数の宣言
多値を返す関数の宣言では、戻り値の型リストを「()」(丸括弧)で囲む。
```go
func 関数名(パラメータリスト) (戻り値の型リスト) {
    //処理
}
```

#### 可変長パラメータ
関数の最終パラメータだけは、「可変長パラメータ」として使用できる。可変長パラメータを使用すると、関数を呼び出す側で、そのパラメータに渡す値の数を自由に決めることができる。
パラメータを可変にするときは関数宣言のパラメータの型の前に「...」を記述する。
```go
package main

import "fmt"
func main() {
    holiday(1, "元旦", "成人の日")
    holiday(2, "建国記念日")
    holiday(3, "春分の日")
}

//可変長パラメータdaysを持つ関数
func holiday(month int, days ...string) {
    fmt.Printf("%d月の祝日は%d日あります。\n, month, len(days))
    for _, day := range days {
        fmt.Println(day)
    }
    fmt.Plintln()
}
```

戻り値に名前をつけることもできる。
#### 関数リテラル
匿名関数で、通常の関数とは異なり、関数リテラルの外側で、宣言された変数にアクセス可能という特徴を持っている。
このような関数を一般的に「クロージャー」という。

#### メソッドについて








